<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OTP Setup</title>
    <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
    crossorigin="anonymous" />
    <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous"></script>
    <script
    src="https://code.jquery.com/jquery-3.7.1.js"
    integrity="sha256-eKhayi8LEQwp4NKxN+CfCh+3qOVUtJn3QNZ0TciWLP4="
    crossorigin="anonymous"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='index.js') }}"></script>
    <title>Secure File Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .file-manager {
            background: white;
            border-radius: 8px;
            padding: 25px;
            margin: 20px auto;
            max-width: 1000px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .file-list-item {
            display: flex;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }
        .file-list-item:hover {
            background: #f8f9fa;
        }
        .editor-container {
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin: 15px 0;
            min-height: 300px;
        }
        .encryption-status {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .encrypted { background: #28a745; }
        .drag-drop-zone {
            border: 2px dashed #007bff;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            margin: 20px 0;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container my-5">
        <h1> Welcome back, {{ username }}</h1>
        <div class="file-manager">
            <!-- File Upload Section -->
            <div class="drag-drop-zone" id="dropZone" ondragover="handleDragOver(event)" ondrop="handleFileDrop(event)">
                <h4>Drag & Drop Files Here</h4>
                <p class="text-muted">or</p>
                <input type="file" id="fileInput" hidden multiple>
                <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                    Select Files
                </button>
                <div class="mt-2 text-muted">
                    <small>Max file size: 100MB â€¢ RSA Encrypted</small>
                </div>
            </div>
            <!-- Key Display Modal -->
            <div class="modal fade" id="keyModal">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header bg-danger text-white">
                            <h5 class="modal-title">ğŸ”‘ Encryption Keys</h5>
                        </div>
                        <div class="modal-body">
                            <div class="mb-4">
                                <label class="form-label">Public Key (For Sharing):</label>
                                <pre class="bg-light p-2 rounded" id="publicKey"></pre>
                            </div>
                            <div class="alert alert-warning">
                                <h5>Private Key (SAVE THIS SECURELY):</h5>
                                <pre class="bg-light p-2 rounded" id="privateKey"></pre>
                                <p class="mt-2">âš ï¸ This key will NOT be stored. Loss = Permanent data inaccessibility</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container mt-5">
                <h1 class="mb-4">File Management</h1>
        
                <!-- File Query Section -->
                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title">Query File</h5>
                        <form id="queryFileForm" onsubmit="queryFile(event)">
                            <div class="mb-3">
                                <label for="filename" class="form-label">File Name</label>
                                <input type="text" class="form-control" id="filename" placeholder="Enter file name" required>
                            </div>
                            <div class="mb-3">
                                <label for="otp" class="form-label">OTP</label>
                                <input type="text" class="form-control" id="otp" placeholder="Enter OTP" required>
                            </div>
                            <div class="mb-3">
                                <label for="secret_key" class="form-label">OTP</label>
                                <textarea type="text" class="form-control" id="secret_key" placeholder="Enter secret key" required></textarea>
                            </div>
                            <button id="query" class="btn btn-primary">Query</button>
                        </form>
                    </div>
                </div>
        
                <!-- File List Section -->
                <div id="fileListContent">
                    <!-- Dynamically Rendered File List -->
                </div>

        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.add('dragover'); // æ·»åŠ è§†è§‰åé¦ˆ
        }
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                await processFiles(e.target.files);
            }
        });
        async function handleFileDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                await processFiles(files);
            }
        }
        // å¤„ç†æ–‡ä»¶ä¸Šä¼ ï¼ŒåŠ å¯†åå†ä¸Šä¼ 
        async function processFiles(files) {
            for (const file of files) {
                // ç”Ÿæˆ RSA å¯†é’¥å¯¹
                const keyPair = await window.crypto.subtle.generateKey({
                    name: "RSA-OAEP",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                    hash: "SHA-256"
                }, true, ["encrypt", "decrypt"]);

                const publicKeyBuffer = await window.crypto.subtle.exportKey("spki", keyPair.publicKey);
                const privateKeyBuffer = await window.crypto.subtle.exportKey("pkcs8", keyPair.privateKey);

                const publicKeyPem = "-----BEGIN PUBLIC KEY-----\n" +
                    btoa(String.fromCharCode(...new Uint8Array(publicKeyBuffer))).match(/.{1,64}/g).join("\n") +
                    "\n-----END PUBLIC KEY-----";

                const privateKeyPem = "-----BEGIN PRIVATE KEY-----\n" +
                    btoa(String.fromCharCode(...new Uint8Array(privateKeyBuffer))).match(/.{1,64}/g).join("\n") +
                    "\n-----END PRIVATE KEY-----";

                const fileArrayBuffer = await file.arrayBuffer();
                const fileBytes = new Uint8Array(fileArrayBuffer);
                const chunkSize = 190;
                let encryptedChunks = [];
                for (let i = 0; i < fileBytes.length; i += chunkSize) {
                    const chunk = fileBytes.slice(i, i + chunkSize);
                    const encryptedChunk = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, keyPair.publicKey, chunk);
                    encryptedChunks.push(new Uint8Array(encryptedChunk));
                }

                let totalLength = encryptedChunks.reduce((sum, arr) => sum + arr.length, 0);
                let encryptedData = new Uint8Array(totalLength);
                let offset = 0;
                for (const arr of encryptedChunks) {
                    encryptedData.set(arr, offset);
                    offset += arr.length;
                }

                const formData = new FormData();
                const encryptedBlob = new Blob([encryptedData], { type: 'application/octet-stream' });
                formData.append('file', encryptedBlob, file.name);
                formData.append('public_key', publicKeyPem);

                const response = await fetch('/upload', { method: 'POST', body: formData });
                const result = await response.json();
                if (result.status === 'success') {
                // æ˜¾ç¤ºå¯†é’¥
                showKeys(publicKeyPem, privateKeyPem);
                } else {
                console.error('Upload error:', result.message || result.error);
                }
            }
        }

        // Upload file to the server
        async function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                return await response.json();
            } catch (error) {
                console.error('File upload error:', error);
                throw error;
            }
        }

                
        async function openEditor(filename) {
            const otp = $('#otp').val().trim();
            const privateKeyPem = $('#secret_key').val().trim();
            if (!filename || !otp || !privateKeyPem) {
            alert("Filename, OTP, and key are required to edit.");
            return;
            }
            const formData = new FormData();
            formData.append('filename', filename);
            formData.append('otp', otp);
            try {
            const res = await fetch('/query_file', { method: 'POST', body: formData });
            const data = await res.json();
            if (data.status === 'success') {
                const pemHeader = "-----BEGIN PRIVATE KEY-----";
                const pemFooter = "-----END PRIVATE KEY-----";
                const pemContents = privateKeyPem.replace(pemHeader, "").replace(pemFooter, "").replace(/\s/g, '');
                const binaryDer = Uint8Array.from(atob(pemContents), c => c.charCodeAt(0));
                const privateKey = await window.crypto.subtle.importKey(
                "pkcs8",
                binaryDer.buffer,
                { name: "RSA-OAEP", hash: "SHA-256" },
                false,
                ["decrypt"]
                );
                const encryptedBytes = Uint8Array.from(atob(data.file.encrypted_content), c => c.charCodeAt(0));
                let decryptedChunks = [];
                for (let i = 0; i < encryptedBytes.length; i += 256) {
                let chunk = encryptedBytes.slice(i, i + 256);
                let decryptedChunk = await window.crypto.subtle.decrypt({ name: "RSA-OAEP" }, privateKey, chunk);
                decryptedChunks.push(new Uint8Array(decryptedChunk));
                }
                let totalLen = decryptedChunks.reduce((sum, arr) => sum + arr.length, 0);
                let decryptedData = new Uint8Array(totalLen);
                let offset = 0;
                for (const arr of decryptedChunks) {
                decryptedData.set(arr, offset);
                offset += arr.length;
                }
                const fileContent = new TextDecoder().decode(decryptedData);
                // æ˜¾ç¤ºç¼–è¾‘ç•Œé¢
                const fileList = document.getElementById('fileListContent');
                fileList.innerHTML = `
                <h3>Edit File: ${filename}</h3>
                <label><input type="checkbox" id="reuseKeyCheckbox"> Reuse Old Private Key?</label>
                <br/><br/>
                <textarea id="editorTextarea" rows="10" class="form-control">${fileContent}</textarea>
                <br/>
                <button id="saveBtn" class="btn btn-primary">Save</button>
                <button id="cancelBtn" class="btn btn-secondary">Cancel</button>
                `;
                // ç»‘å®šä¿å­˜/å–æ¶ˆæŒ‰é’®äº‹ä»¶
                $(document).on('click', '#saveBtn', function(){
                const updatedContent = $('#editorTextarea').val();
                const reuseKey = $('#reuseKeyCheckbox').prop('checked');
                saveChanges(filename, updatedContent, otp, reuseKey, privateKeyPem);
                });
                $('#cancelBtn').on('click', function() {
                fileList.innerHTML = '';
                });
            } else {
                alert(`Error retrieving file content: ${data.message}`);
            }
            } catch (error) {
            alert("Failed to load file content for editing");
            }
        }
        // ç›‘å¬ç¼–è¾‘æŒ‰é’®ç‚¹å‡»ï¼Œè°ƒç”¨openEditor
        $(document).on('click', '#edit', function(e) {
            e.preventDefault();
            const filename = $('#filename').val().trim();
            openEditor(filename);
        });
        

        async function saveChanges(filename, updatedContent, otp, reuseKey, oldPrivateKeyPem) {
            // å°†updatedContentåŠ å¯†
            let encryptedDataBase64 = "";
            let newPrivateKeyPem = "";
            const formData = new FormData();
            if (reuseKey) {
            // é‡ç”¨æ—§å¯†é’¥ï¼šä»ç§é’¥å¯¼å‡ºå…¬é’¥ç”¨äºåŠ å¯†
                const pemHeader = "-----BEGIN PRIVATE KEY-----";
                const pemFooter = "-----END PRIVATE KEY-----";
                const pemContents = oldPrivateKeyPem.replace(pemHeader, "").replace(pemFooter, "").replace(/\s/g, '');
                const binaryDer = Uint8Array.from(atob(pemContents), c => c.charCodeAt(0));
                const oldPrivateKey = await window.crypto.subtle.importKey(
                    "pkcs8",
                    binaryDer.buffer,
                    { name: "RSA-OAEP", hash: "SHA-256" },
                    true,    // å…è®¸å¯¼å‡ºå…¬é’¥
                    ["decrypt"]
                );
                const publicKeyBuffer = await window.crypto.subtle.exportKey("spki", oldPrivateKey);
                const oldPublicKey = await window.crypto.subtle.importKey(
                    "spki",
                    publicKeyBuffer,
                    { name: "RSA-OAEP", hash: "SHA-256" },
                    false,
                    ["encrypt"]
                );
                // ç”¨æ—§å…¬é’¥åŠ å¯†æ›´æ–°å†…å®¹
                const contentBytes = new TextEncoder().encode(updatedContent);
                let encryptedChunks = [];
                for (let i = 0; i < contentBytes.length; i += 190) {
                    const chunk = contentBytes.slice(i, i + 190);
                    const encryptedChunk = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, oldPublicKey, chunk);
                    encryptedChunks.push(new Uint8Array(encryptedChunk));
                }
                let totalLen = encryptedChunks.reduce((sum, arr) => sum + arr.length, 0);
                let encryptedData = new Uint8Array(totalLen);
                let offset = 0;
                for (const arr of encryptedChunks) {
                    encryptedData.set(arr, offset);
                    offset += arr.length;
                }
                encryptedDataBase64 = btoa(String.fromCharCode(...encryptedData));
            } else {
            // ä¸é‡ç”¨æ—§å¯†é’¥ï¼šç”Ÿæˆæ–°çš„RSAå¯†é’¥å¯¹
                const newKeyPair = await window.crypto.subtle.generateKey(
                    {
                    name: "RSA-OAEP",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                    hash: "SHA-256"
                    },
                    true,
                    ["encrypt", "decrypt"]
                );
                // å¯¼å‡ºæ–°å¯†é’¥å¯¹ï¼ˆPEMï¼‰ï¼Œç”¨äºæç¤ºç”¨æˆ·ä¿å­˜
                const newPubBuf = await window.crypto.subtle.exportKey("spki", newKeyPair.publicKey);
                const newPrivBuf = await window.crypto.subtle.exportKey("pkcs8", newKeyPair.privateKey);
                const newPublicKeyPem = "-----BEGIN PUBLIC KEY-----\n" +
                    btoa(String.fromCharCode(...new Uint8Array(newPubBuf))).match(/.{1,64}/g).join("\n") +
                    "\n-----END PUBLIC KEY-----";
                newPrivateKeyPem = "-----BEGIN PRIVATE KEY-----\n" +
                    btoa(String.fromCharCode(...new Uint8Array(newPrivBuf))).match(/.{1,64}/g).join("\n") +
                    "\n-----END PRIVATE KEY-----";
                // ç”¨æ–°å…¬é’¥åŠ å¯†æ›´æ–°å†…å®¹
                const contentBytes = new TextEncoder().encode(updatedContent);
                let encryptedChunks = [];
                for (let i = 0; i < contentBytes.length; i += 190) {
                    const chunk = contentBytes.slice(i, i + 190);
                    const encChunk = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, newKeyPair.publicKey, chunk);
                    encryptedChunks.push(new Uint8Array(encChunk));
                }
                let totalLen = encryptedChunks.reduce((sum, arr) => sum + arr.length, 0);
                let encryptedData = new Uint8Array(totalLen);
                let offset = 0;
                for (const arr of encryptedChunks) {
                    encryptedData.set(arr, offset);
                    offset += arr.length;
                }
                encryptedDataBase64 = btoa(String.fromCharCode(...encryptedData));
                // å°†æ–°å…¬é’¥å‘é€ç»™æœåŠ¡å™¨ï¼ˆæœåŠ¡å™¨ç›®å‰ä¸ä½¿ç”¨è¯¥å€¼ï¼Œåªè®°å½•æ—¥å¿—ï¼‰
                formData.append('public_key', newPublicKeyPem);
            }
            // è°ƒç”¨åç«¯/update_fileæ¥å£æäº¤åŠ å¯†åçš„å†…å®¹
            formData.append('filename', filename);
            formData.append('newContent', encryptedDataBase64);
            formData.append('reuse_key', reuseKey ? 'true' : 'false');
            formData.append('otp', otp || '');
            try {
                const res = await fetch('/update_file', { method: 'POST', body: formData });
                const data = await res.json();
                const fileList = document.getElementById('fileListContent');
                fileList.innerHTML = '';
                if (data.status === 'success') {
                    if (reuseKey) {
                    // æç¤ºä½¿ç”¨æ—§å¯†é’¥ï¼Œæ— éœ€æ–°å¯†é’¥
                    const msg = document.createElement('p');
                    msg.innerText = "File updated successfully (using existing key).";
                    fileList.appendChild(msg);
                    } else {
                    // æ˜¾ç¤ºæ–°ç§é’¥ç»™ç”¨æˆ·ä¿å­˜
                    const msg = document.createElement('p');
                    msg.innerText = "Successfully updated file. Below is the NEW private key, save it securely:";
                    const textArea = document.createElement('textarea');
                    textArea.rows = 10;
                    textArea.style.width = "100%";
                    textArea.value = newPrivateKeyPem;
                    const copyBtn = document.createElement('button');
                    copyBtn.innerText = "Copy";
                    copyBtn.onclick = function() {
                        textArea.select();
                        document.execCommand("copy");
                        alert("New private key copied to clipboard.");
                    };
                    fileList.appendChild(msg);
                    fileList.appendChild(textArea);
                    fileList.appendChild(copyBtn);
                    }
                } else {
                    alert(`Failed to update file: ${data.message}`);
                }
            } catch (error) {
            alert("Error occurred while updating file.");
            }
        }


        // Display the public and private keys
        function showKeys(publicKey, privateKey) {
            document.getElementById('publicKey').textContent = publicKey;
            document.getElementById('privateKey').textContent = privateKey;

            // æ˜ç¡®åˆå§‹åŒ–å¹¶æ˜¾ç¤ºmodal
            const modalElement = document.getElementById('keyModal');
            const keyModal = bootstrap.Modal.getOrCreateInstance(modalElement);
            keyModal.show();
        }
    </script>
</body>

<script>
    // Function to render file list dynamically
    function renderFileList(files, currentUser) {
        const fileListContent = document.getElementById('fileListContent');
        fileListContent.innerHTML = ''; // Clear existing content

        files.forEach(file => {
            const isOwner = file.owner === currentUser;
            const isShared = file.shared_to.includes(currentUser);

            const fileItem = document.createElement('div');
            fileItem.className = 'file-list-item';

            // Encryption status indicator
            const encryptionStatus = document.createElement('div');
            encryptionStatus.className = 'encryption-status encrypted';
            fileItem.appendChild(encryptionStatus);

            // File details
            const fileDetails = document.createElement('div');
            fileDetails.className = 'flex-grow-1';

            const fileInfo = document.createElement('div');
            fileInfo.className = 'd-flex justify-content-between align-items-center';

            const fileNameSection = document.createElement('div');
            fileNameSection.innerHTML = `
                <span class="file-name">${file.filename}</span>
                <small class="text-muted ms-2">${file.file_size} KB â€¢ Modified ${file.modified_time}</small>
            `;
            fileInfo.appendChild(fileNameSection);

            // File actions
            const fileActions = document.createElement('div');
            fileActions.className = 'file-actions';

            if (isOwner) {
                fileActions.innerHTML = `
                    <button class="btn btn-sm btn-outline-primary" onclick="openEditor('${file.fileid}')">
                        <i class="bi bi-pencil"></i> Edit
                    </button>
                    
                    <button class="btn btn-sm btn-outline-success" onclick="showSharingOptions('${file.fileid}')">
                        <i class="bi bi-people"></i> Share
                    </button>
                    <button class="btn btn-sm btn-outline-danger" onclick="deleteFile('${file.fileid}')">
                        <i class="bi bi-trash"></i> Delete
                    </button>
                `;
            } else if (isShared) {
                fileActions.innerHTML = `
                    <button class="btn btn-sm btn-outline-primary" onclick="viewFile('${file.fileid}')">
                        <i class="bi bi-eye"></i> View
                    </button>
                `;
            }

            fileInfo.appendChild(fileActions);
            fileDetails.appendChild(fileInfo);

            // Shared with section
            const sharedWithSection = document.createElement('div');
            sharedWithSection.className = 'shared-with mt-1';
            sharedWithSection.innerHTML = `<small>Shared with: ${file.shared_to.join(', ')}</small>`;
            fileDetails.appendChild(sharedWithSection);

            fileItem.appendChild(fileDetails);
            fileListContent.appendChild(fileItem);
        });
    }

    
</script>

</html>
